---
layout: post
title: "Бинарный алгоритм поиска на Javascript"
description: "Базовые алгоритмы на практике - бинарный алгоритм поиска на Javascript"
author: "Paul Finch"
categories: javascript
tags: [ES6, Algorithm, Binary Search, Computer Science]
image: binary-search.jpg
---

Алгоритмом называется набор инструкций для выполнения некоторой задачи, некая последовательность действий. Сегодня мы рассмотрим простейший алгоритм - бинарный поиск. Он рассматривается во многих учбениках по программированию.

<!--excerpt-->

Чтобы понять о чем речь, стоит привести конкретные примеры. Предположим, вы ищете фамилию человека в телефонной книге. Она начинается с буквы «К». Конечно, можно начать с самого начала и перелистывать страницы, пока вы не доберетесь до буквы «К». Но для ускорения поиска лучше раскрыть книгу на середине: ведь буква «К» должна находиться гдето ближе к середине телефонной книги. Илb же у Вас есть отсортированный массив числе от 1 до 100 например, и Вам нужно найти число в нем, за минимально возможное количество шагов. Во всех этих случаях можно применить - **_бинарный поиск_**

Бинарный поиск - это алгоритм, который на входе он получает отсортированный список элементов/чисел. Если элемент, который вы ищете, присутствует в списке, то бинарный поиск возвращает ту позицию, в которой он был найден. В противном случае бинарный поиск возвращает _null_.



### Реализация на Javascript

```javascript
// количество попыток
let iteration = 0;

function binarySearch(arr, item) {
    let low = 0,
        high = arr.length - 1;

    while(low<=high) {
        // центральный элемент
        // Math.floor округляет в меньшую сторону
        let mid = Math.floor((high+low)/2);

        if( arr[mid] === item ) {
            iteration++; // попытка++
            return mid
        } else if( arr[mid] > item ) {
            iteration++; // попытка++
            high = mid - 1;
        } else  {
            iteration++; // попытка++
            low = mid + 1;
        }
    }

    return null // вернет null если не найдено ничего
}
```
Введем переменную iteration равную 0. Это будет количество попыток, необходимых для вычисления позиции искомого числа. Этот параметр не обязателен, но нужен чтобы показать наглядно, как работает бинарный поиск.

<br/>
### Тестирование

Итак, напишем функцию по генерации отсортированного массива заданной длинны.
```javascript
const generateArray = (size, callback) => {
    let arr = [];
    
    for(let i=0; i<=size; i++) {
        arr[i] = i;
    }
    return callback(arr);
}
``` 
После генерации массива указанной длинны(параметр *size*) с ним можно выполнять любые действия с помощью функции *callback*. Создадим пустой массив *buf*, и с помощью метода *generateArray* вставим туда 100 элементов. 
```javascript
let buf = [];

generateArray(100, function(elems){
	// ... - оператор spread из ES6
    buf = [...elems];
})
```
Затем вызовим метод *binarySearch* и будем в нем искать число 98. Выведем в консоль наше количество попыток, то есть параметр *iteration*
```javascript
binarySearch(buf,98)
console.dir( iteration )
```
Мы видим что для списка размером 100 элементов необходимо максимум 7 попыток. Неплохо! Ведь если искать простым перебором то потребуется количество попыток, равное 100 попыткам. А что если искать слово или число в массиве состоящем из 240 000 элементов?
```javascript
generateArray(240000, function(elems){
	// ... - оператор spread из ES6
    buf = [...elems];
})

binarySearch(buf,98)
console.dir( iteration ) // 18
```
Максимум 18 попыток? Неплохо! То есть можно сделать вывод, что бинарный поиск выполняется за __*log <sub>2</sub> n*__ шагов, тогда как простой поиск будет выполнен за __*n*__ шагов. Следовательно __*log <sub>2</sub> 100 &asymp; 6,77*__, а __*log <sub>2</sub> 240000 &asymp; 17,87*__. 

*При подготовке статьи были использвоаны материалы книги - "Grokking Algorithms".*